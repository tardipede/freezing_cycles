---
title: "3. Freezing cycles tolerance vs. environmental variables"
author: "Matteo Vecchi"
date: "`r Sys.Date()`"
editor_options:
  chunk_output_type: console
output: 
  workflowr::wflow_html:
    code_folding: hide 
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, include=FALSE}
library(tidyverse)
library(raster)
library(readxl)
library(dplyr)
library(rgdal)
library(ape)
library(bayestestR)
library(R2jags)
library(patchwork)
```

```{r load points coordinates}
points = data.frame(read_xlsx("./data/data_freezing.xlsx", sheet = "species_data"))[,1:3]
```


```{r get bioclim}
# The 30' resolution BIoclims rasters are heavy, so I load the point data extracted previously.
#If you want to do it by yourself put the bioclim rasters 1:11 in a folder in the data folder and run the following code
#bioclim_stack = stack(list.files("./data/bioclim/", full.names = TRUE))
#bioclims_extracted = data.frame(raster::extract(bioclim_stack, points[,3:2]))

bioclims_extracted = read.table("./data/bioclim_data.txt", header=T)
pca_bioclims = prcomp(bioclims_extracted, scale=T)
```

```{r simplify PCA}
# function to permute the dataset
data_permute = function(x){
  for (i in 1:ncol(x)){
    x[,i]=base::sample(x[,i],size=length(x[,i]),replace=F)}
  return(x)
}

# Create a set of 1000 null  PCAs
pca_nulls = list()
for (i in 1:1000){
  pca_nulls[[i]] = prcomp(data_permute(bioclims_extracted),scale.=T,center=T)
}


# Get null distribution of explained variance
eig_nulls = lapply(pca_nulls, function(x){(x$sdev)^2/sum((x$sdev)^2)})
eig_nulls = data.frame(do.call(rbind,eig_nulls))
colnames(eig_nulls) = c("PC1","PC2","PC3","PC4")
# Explained variance on observed data
eig_obs = (pca_bioclims$sdev)^2/sum((pca_bioclims$sdev)^2)

# Calculate explained variance p-values
eig_pvals = c()
for (i in 1:length(eig_obs)){
  eig_pvals[i] = mean(eig_obs[i] < eig_nulls[,i])
}
names(eig_pvals) = paste0("PC",1:11)
eig_pvals

# Create a function to calculate the ILs of the components loadings
IL = function(x, component){
  eig = (x$sdev^2)[component]
  ILs = (x$rotation[,component]^2)*eig^2 
  return(ILs)
}

# PC1
IL_observed_PC1 = IL(pca_bioclims,1)
IL_nulls_PC1 = data.frame(do.call(rbind,lapply(pca_nulls,IL, component=1)))

# Calculate PC1 IL p-values
IL_PC1_pvals = c()
for (i in 1:length(IL_observed_PC1)){
  IL_PC1_pvals[i] = mean(IL_observed_PC1[i] < IL_nulls_PC1[,i])
}
names(IL_PC1_pvals) = colnames(IL_nulls_PC1) 

# PC2
IL_observed_PC2 = IL(pca_bioclims,2)
IL_nulls_PC2 = data.frame(do.call(rbind,lapply(pca_nulls,IL, component=2)))

# Calculate PC2 IL p-values
IL_PC2_pvals = c()
for (i in 1:length(IL_observed_PC2)){
  IL_PC2_pvals[i] = mean(IL_observed_PC2[i] < IL_nulls_PC2[,i])
}
names(IL_PC2_pvals) = colnames(IL_nulls_PC2) 


# Create a simplified PC1 (sPC1)
simplified_loadings_PC1 = pca_bioclims$rotation[,1] * (IL_PC1_pvals<0.05)
sPC1 = as.matrix(scale(bioclims_extracted)) %*% as.matrix(simplified_loadings_PC1)

# Create a simplified PC2 (sPC2)
simplified_loadings_PC2 = pca_bioclims$rotation[,2] * (IL_PC2_pvals<0.05)
sPC2 = as.matrix(scale(bioclims_extracted)) %*% as.matrix(simplified_loadings_PC2)

# test if PC1 and sPC1 are correlated
plot(pca_bioclims$x[,1],sPC1, xlab="sPC1", ylab="PC1")
abline(lm(sPC1~pca_bioclims$x[,1]))
cor.test(sPC1,pca_bioclims$x[,1]) 

# test if PC2 and sPC2 are correlated
plot(pca_bioclims$x[,2],sPC2, xlab="sPC2", ylab="PC2")
abline(lm(sPC2~pca_bioclims$x[,2]))
cor.test(sPC2,pca_bioclims$x[,2])

#Calculate the new eigenvalue for sPC
tot.var = sum(pca_bioclims$sdev^2)
sPC1var = var(sPC1)
sPC1.expvar = sPC1var/tot.var

#Calculate the new eigenvalue for sPC2
sPC2var = var(sPC2)
sPC2.expvar = sPC2var/tot.var

# Create new PCs data frame
sPCs = data.frame(species_code = points$species_code,
                  sPC1 = sPC1,
                  sPC2 = sPC2)

# create loadings dataframe
sloadings = data.frame(bioclim  = names(simplified_loadings_PC1),
                       sPC1 = simplified_loadings_PC1,
                       sPC2 = simplified_loadings_PC2)


```


```{r merge environmental data with freezing tolerance data}
data_merged = merge(read.table("./output/means_cycles.txt", header=T),sPCs)
data_merged$scaled_M = as.numeric(scale(data_merged$M))
```

```{r load phylogenetic tree}
tree = chronos(read.nexus("./data/tree.nex"))
tree = drop.tip(tree, tip = tree$tip.label[!(tree$tip.label %in% data_merged$species)])
class(tree) = "phylo"

data_merged = data_merged[data_merged$species %in% tree$tip.label,]
```

```{r}

phylo.matrix = vcv.phylo(tree)
inv.phylo.matrix = solve(phylo.matrix)

data_merged = data_merged[match(rownames(inv.phylo.matrix),data_merged$species),]

data.jags = list(M = data_merged$scaled_M,
                 sPC1 = as.numeric(scale(data_merged$sPC1)),
                 sPC2 = as.numeric(scale(data_merged$sPC2)),
                 inv.phylo.matix = inv.phylo.matrix,
                 nsp = nrow(inv.phylo.matrix),
                 zeros = rep(0, nrow(inv.phylo.matrix)))

# The model includes some truncated priors. As it is not possible to do it by specifying the modell as function in R, the moded is loaded as txt file.

parameters.jags = c("alpha","beta_spc1","beta_spc2","sigma.phylo","sigma.res")


ifelse("mod.env.rds" %in% list.files("./output"),{fit.env = readRDS("./output/mod.env.rds")},{

  fit.env = jags(data = data.jags,
               parameters.to.save = parameters.jags,
               model.file = "./code/model.txt",
               n.chains = 3, n.iter = 1000000)
write_rds(fit.env, file="./output/mod.env.rds")
  
})
```


```{r get model bayesian pvalues}
chains = data.frame(do.call(rbind,as.mcmc(fit.env)))

p_dir = p_direction(chains[,1:3])
p_vals = pd_to_p(p_dir$pd)
names(p_vals) = p_dir$Parameter
p_vals
```

```{r plot}
chains_to_plot = gather(chains[,c(2:3)],"variable","value")
chains_to_plot$variable = factor(chains_to_plot$variable, levels = c("beta_spc2","beta_spc1"))

medians = aggregate(chains_to_plot$value, by=list(chains_to_plot$variable), FUN = median)

plot1 = ggplot(chains_to_plot )+
  theme_bw()+
  geom_hline(yintercept = 0, col="red")+
  geom_violin(aes(x=variable, y=value), alpha=0.5, show.legend=T, color="NA", fill="lightblue")+
  #scale_fill_viridis_c()+
  stat_summary(aes(x=variable, y=value),fun=median, colour="black", geom="point", size = 3)+
  stat_summary(aes(x=variable, y=value),fun.data=median_hilow, colour="black", geom="linerange")+
  geom_text(data= medians,aes(x=(1:2)+0.1, y=medians[,2], label = paste0("p = ",round(p_vals[3:2],4))))+
  xlab("")+ylab("")+coord_flip()+
  theme(panel.grid.major.y = element_blank(), panel.grid.minor = element_blank(),panel.border =    element_blank())



plot2 = ggplot(sloadings)+
        theme_bw()+
         geom_hline(yintercept = 0, col="black")+
        geom_bar(stat="identity", aes(x=bioclim, y=sPC1))+
  xlab("")+ylab("Contribution to sPC1")+
  theme(panel.grid.major.y = element_blank(), panel.grid.minor = element_blank(),panel.border =    element_blank())+
  scale_x_discrete(label = paste0("Bioc",1:11))

plot3 = ggplot(sloadings)+
        theme_bw()+
        geom_hline(yintercept = 0, col="black")+
        geom_bar(stat="identity", aes(x=bioclim, y=sPC2))+
  xlab("")+ylab("Contribution to sPC2")+
  theme(panel.grid.major.y = element_blank(), panel.grid.minor = element_blank(),panel.border =    element_blank())+
  scale_x_discrete(label = paste0("Bioc",1:11))

plot1|(plot2/plot3)

```

